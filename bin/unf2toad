#!/usr/bin/env python
# -*- coding: utf-8 -*-
import ConfigParser
import tempfile
import argparse
import tarfile
import shutil
import glob
import sys
import os
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..'))
from lib import util
from collections import OrderedDict

__author__ = "Guillaume Vallet, Mathieu Desrosiers"
__copyright__ = "Copyright 2015, The Toad Project"
__credits__ = ["Guillaume Vallet", "Mathieu Desrosiers"]
__license__ = "GPL"
__version__ = "1.0"
__maintainer__ = "Mathieu Desrosiers"
__email__ = "mathieu.desrosiers@criugm.qc.ca"
__status__ = "Development"


class Session(object):

    def __init__(self):
        self.name = None
        self.dirty = None

    def __repr__(self):
        return "name = {}, dirty = {}".format(self.name, self.dirty)

    def __eq__(self, other):
        return (isinstance(other, type(self))
                and self.name == other.name)


class Sequence(object):

    def __init__(self):
        self.session = None
        self.sequence = None
        self.path = None

    def __repr__(self):
        return "session = {}, sequence = {}, path = {}".format(self.session, self.sequence, self.path)

    def __eq__(self, other):
        return (isinstance(other, type(self))
                and (self.session, self.sequence,  self.path) == (other.session, other.sequence, self.path))


class Unftoad(object):

    __initialPrefixs = OrderedDict([('anat', "Anatomical (T1--MPRAGE)"),
                                    ('dwi', "Diffusion weighted image (DWI - DTI)"),
                                    ('b0_ap', "B0 AP (anterior -> posterior)"),
                                    ('b0_pa', "B0 PA (posterior -> anterior)")])

    __fieldmap = OrderedDict([('mag', "Magnitude fieldmap"),
                               ('phase', "Phase fieldmap")])


    def __init__(self):

        self.__arguments = None
        self.__prefixs = OrderedDict()
        self.__sessions = OrderedDict()
        self.__sequences = OrderedDict()

    #@TODO none unf options, reshuffle dicom
    #@TODO a user may choose is strides values
    def run(self):

        self.__arguments = self.__parseArguments()
        self.__extractPrefixsFromConfig()
        rootDirectories = self.__extractRootsDirectory(self.__arguments.sources)
        self.__initializeStructures(rootDirectories)


        while len(self.__sessions) > 0:

            if len(self.__sessions) == 1:
                index = 0
            else:
                index = self.__chooseOption(self.__sessions, "Please choose a session to convert")
                if index == -1:
                    break

            session = self.__sessions.items()[index]
            self.__markSessionAsSelected(session)

            self.__printQuestion()
            answer = raw_input("Please enter a subject name? Defaults {} :".format(session[0]))
            subjectName = answer if answer.strip(" ") != "" else session[0]

            outputDir = self.__arguments.dirName if self.__arguments.dirName else "toad_data"
            targetDir = os.path.join(os.getcwd(), outputDir, subjectName)

            if not os.path.exists(targetDir):
                os.makedirs(targetDir)

            configFile = "{}/config.cfg".format(targetDir)

            sequences = self.__getSequencesBySession(session)
            selectedSequences = self.__getSelectedSequences(sequences)

            if len(selectedSequences) > 0:

                isPrefixHaveBeenChange = self.__isUserDefinedCustomPrefixs(selectedSequences)
                if isPrefixHaveBeenChange:
                    prefixs = self.__defineCustomPrefixs()
                    if not self.__arguments.noConfig:
                        self.__setPrefixInConfigFiles(prefixs, configFile)
                else:
                    prefixs = self.__prefixs

                for prefix, sequence in selectedSequences.iteritems():
                    if prefix == 'dwi':
                        self.__convertDwi(sequence, subjectName, prefixs[prefix], targetDir, configFile)
                    elif prefix == 'mag':
                        self.__convertMagnitude(sequence,
                                                subjectName,
                                                prefixs[prefix],
                                                targetDir,
                                                configFile)
                    else:
                        self.__convert(index, sequence, subjectName, prefixs[prefix], targetDir)

            if len(self.__sessions) == 1:
                break

        #cleanup temporary directories
        for (directory, archive) in rootDirectories:
            if archive is not None:
                shutil.rmtree(directory)

    def __parseArguments(self):
        """Prepare and parse user friendly command line arguments for sys.argv.

        Returns:
            a args stucture containing command lines arguments
        """
        parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                         description ="""\n

             """)
        parser.add_argument("sources", nargs='+', help="A list or a single UNF mri session")
        parser.add_argument("-c", "--config", nargs='?',metavar=('filename'), required=False,
                                help="Specify the location of an alternative the config.cfg as input. Default: etc/config.cfg")
        parser.add_argument("-f","--fieldmap", help="Add fieldmap capability", action="store_true")
        parser.add_argument("-n","--noConfig", help="Do not produce the config.cfg file into the root folder", action="store_true")
        parser.add_argument("-s","--noStride", help="Keep original stride orientation.", action="store_true")

        parser.add_argument("-d", "--dirName", nargs='?', metavar=('dirname'), required=False,
                            help="Specify the name of the destination directory. Default: toad_data")

        args = parser.parse_args()
        return args


    def __extractRootsDirectory(self, sources):
        """ define directories who qualify for dicom extraction

        Args
            source: a list of  source directory as specified in command line

        Returns
            A list of tuples. Each tuple have 2 elements
                first element: the session directory
                second element: source archive name if the session is inside an archive, None otherwise
        """
        rootDirectories = []
        for source in sources:
            realSource = os.path.realpath(source)
            if os.path.isdir(realSource):
                rootDirectories.append((realSource, None))
            else:
                try:
                    print "Unarchiving {} file, This may take a while...".format(os.path.basename(realSource))
                    tmpDirectory = tempfile.mkdtemp()
                    tar = tarfile.open(realSource, 'r')
                    tar.extractall(tmpDirectory)
                    tar.close()
                    tmpSessions = glob.glob("{}/*".format(tmpDirectory))
                    for tmpSession in tmpSessions:
                        if os.path.isdir(tmpSession):
                            rootDirectories.append((tmpSession, os.path.basename(realSource)))
                except tarfile.TarError:
                    print "Could not determine {} file type, Discarded".format(os.path.basename(realSource))
        return rootDirectories


    def __initializeStructures(self, directories):
        """Initialize session end sequences structures

        Args:
            directories: A list of tuples. first element is the session directory, second element is the source
                            archive name if the session is inside an archive, None otherwise

        """
        numberOfDicoms = 0
        for rootDirectory, origin in directories:
            dicoms = glob.glob("{}/*/*.dcm".format(rootDirectory))
            numberOfDicoms += len(dicoms)
            dicoms.extend(glob.glob("{}/*/*/*.dcm".format(rootDirectory)))
            dicoms = sorted(dicoms)
            for dicom in dicoms:
                sequence = Sequence()
                sequence.session = os.path.basename(rootDirectory)
                sequence.path = os.path.split(dicom)[0].replace(" ", "\ ")
                path = sequence.path.replace(rootDirectory, '')
                if path[0] == "/":
                    path = path[1:]
                sequence.sequence = path.split("/")[0]
                if not self.__sequences.has_key((sequence.session, sequence.sequence)):
                    self.__sequences[(sequence.session, sequence.sequence)]= sequence

        for index, sequence in self.__sequences.iteritems():
            if not self.__sessions.has_key(sequence.session):
                self.__sessions[sequence.session] = False


    def __markSessionAsSelected(self, session):
        sessions= OrderedDict()
        for name, value in self.__sessions.iteritems():
            if session[0] == name:
                sessions[name] = True
            else:
                sessions[name] = value
        self.__sessions =  sessions


    def __getSequencesBySession(self, session):

        sequences = OrderedDict()
        for index, value in self.__sequences.iteritems():
            if session[0] == index[0]:
                sequences[index] = value
        return sequences


    def __getSelectedSequences(self, sequences):
        selectedSequences={}
        for (index, value) in self.__initialPrefixs.iteritems():
            choice = self.__chooseOption(sequences, "Please select the {} image\n".format(value))
            if choice != -1:
                selectedSequences[index] = sequences.items()[choice][1]
        return selectedSequences


    def __isUserDefinedCustomPrefixs(self, sequences):
        self.__printQuestion("Whould you like to change default prefix at the beginning of the filename? Actual are ...\n\n")
        message = ""
        for index, value in self.__prefixs.iteritems():
            if sequences.has_key(index):
                        message+= "\t{} will be prefix: {} \n".format(self.__initialPrefixs[index], value)
        return util.displayYesNoMessage(message, "Change prefix (y or n)? Default n :", "no")


    def __defineCustomPrefixs(self):
        prefixs = OrderedDict()
        for index, value in self.__prefixs.iteritems():
            self.__printQuestion()
            message = "Enter new prefix for {} image. Default {} :".format(self.__initialPrefixs[index], value)
            input = raw_input(message)
            if input.strip(" ") != "":
                prefixs[index]="{}_".format(input)
        return prefixs


    def __extractPrefixsFromConfig(self):

        #look if fieldmap support is needed
        if self.__arguments.fieldmap:
            self.__initialPrefixs.update(self.__fieldmap)

        config = ConfigParser.ConfigParser()
        configFiles = []
        configFiles.append(os.path.dirname(os.path.realpath(__file__)).replace("bin", "etc/config.cfg"))
        if self.__arguments.config:
            if os.path.isfile(self.__arguments.config):
                configFiles.append(self.__arguments.config)

        for configFile in configFiles:
            config.read(configFile)
        for (prefix, value) in self.__initialPrefixs.iteritems():
            self.__prefixs[prefix] = config.get('prefix', prefix)



    def __chooseOption(self, dictionnary, question):
        while True:
            self.__printQuestion(question)
            print(" 0.  None or exit")
            for name, value in dictionnary.iteritems():
                if type(value) == bool:
                    if value:
                        print("{:2d}.  {} *".format(dictionnary.keys().index(name)+1, name))
                    else:
                        print("{:2d}.  {}".format(dictionnary.keys().index(name)+1, name))
                else:
                    print("{:2d}.  {}".format(dictionnary.keys().index(name)+1, name[1]))

            choice = raw_input("Enter your choice [0-"+str(len(dictionnary))+"]: Default None [0] :")
            if choice.strip(" ") == "":
                choice = 0
            if int(choice) == 0 or 0 <= int(choice)-1 <= len(dictionnary)-1:
               break
            else:
                print("Invalid choice, please enter a valid number")
        return int(choice)-1


    def __setDwiParametersInConfigFiles(self, configFile, dicomImage):
        cmd = "toadinfo {} -c {}".format(dicomImage, configFile)
        if self.__arguments.fieldmap:
            cmd += " --fieldmap "
        print cmd
        util.launchCommand(cmd)


    def __setPrefixInConfigFiles(self, prefixs, configFile):
        config = ConfigParser.ConfigParser()
        config.read(configFile)
        if not config.has_section('prefix'):
            config.add_section('prefix')
        for (item, value) in prefixs.items():
            config.set('prefix', item, value)
        with open(configFile,'wb') as f:
            config.write(f)


    def __setMagnitudeFieldmapInConfigFiles(self, source, echo1, echo2):
        config = ConfigParser.ConfigParser()
        if os.path.exists(source):
            config.read(source)
        if not config.has_section("fieldmap"):
            config.add_section('fieldmap')
        config.set('fieldmap', "echo_time_mag1", echo1)
        config.set('fieldmap', "echo_time_mag2", echo2)
        with open(source,'w') as w:
            config.write(w)


    def __printQuestion(self, question=None):
        os.system("clear")
        print("\n\n"+45*"-")
        if question is not None:
            print question


    def __convert(self, type, sequence, subjectName, prefix, target):
        filename = "{}/{}{}".format(target, prefix, subjectName)
        cmd = "mrconvert {0} {1}.nii.gz -force ".format(sequence.path, filename)
        if not self.__arguments.noStride:
            cmd += " -stride 1,2,3 "

        if type == 'phase':
            cmd += " -datatype float32 "

        print cmd
        util.launchCommand(cmd)


    def __convertDwi(self, sequence, subjectName, prefix, target, configFile):
        filename = "{}/{}{}".format(target, prefix, subjectName)
        cmd = "mrconvert {0} {1}.nii.gz -force -export_grad_fsl {1}.bvecs {1}.bvals"\
            .format(sequence.path, filename)
        if not self.__arguments.noStride:
            cmd += " -stride 1,2,3,4 "
        print cmd
        util.launchCommand(cmd)

        if not self.__arguments.noConfig:
            dicoms = glob.glob("{}/*.dcm".format(sequence.path))
            if len(dicoms) > 0:
                self.__setDwiParametersInConfigFiles(configFile, dicoms.pop())


    def __convertMagnitude(self, sequence, subjectName, prefix, target, configFile):
        values = []
        for directory in glob.glob("{}/echo*".format(os.path.dirname(sequence.path))):
            values.append((os.path.basename(directory).strip('echo_'), directory))
        try:
            echo1 = float(values[0][0])
            echo2 = float(values[1][0])

            if echo1 > echo2:
                source = values[0][1]
                if not self.__arguments.noConfig:
                    self.__setMagnitudeFieldmapInConfigFiles(configFile, echo2, echo1)
            else:
                source = values[1][1]
                if not self.__arguments.noConfig:
                    self.__setMagnitudeFieldmapInConfigFiles(configFile, echo1, echo2)

        except ValueError:
            source = echo1

        filename = "{}/{}{}".format(target, prefix, subjectName)
        cmd = "mrconvert {0} {1}.nii.gz -force ".format(source, filename)
        if not self.__arguments.noStride:
            cmd += " -stride 1,2,3 "
        print cmd
        util.launchCommand(cmd)


if __name__ == '__main__':
    toad = Unftoad()
    toad.run()

